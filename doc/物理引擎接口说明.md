物理引擎接口说明
======================

作者：朱凯
日期：2017年01月03日

## 1 结构分析

### 1.1 类定义
+ 冰球类。
+ 球桌类。
+ 击球器类。

### 1.2 关键函数

根据以上的类，以及如下需求：

输入：击球器的当前位置和速度（受机器人控制）。
输出：冰球的当前位置和速度。
可以得知关键函数是碰撞检测以及碰撞后的速度计算。其中难点是碰撞检测。

## 2 接口设计

由于C++的自由度远比Java的高，故可以不完全按Java的设计模式处理实现问题。

### 2.1 算法接口——Interpolation

![](http://images2015.cnblogs.com/blog/1068928/201701/1068928-20170102170342909-2001744609.png)

### 2.2 配置接口——InterpolationConfigure

![](http://images2015.cnblogs.com/blog/1068928/201701/1068928-20170102170833300-713468685.png)

## 3 实现接口

只需要按如下图使用public属性实现接口即可：

![](http://images2015.cnblogs.com/blog/1068928/201701/1068928-20170102170946253-1632623010.png)

## 4 使用接口

### 4.1 配置

```c++
InterpolationConfigure *new_cmd;                // 定义为配置接口的指针
new_cmd = new TrapezoidInterpolation();         // 设定算法类型
new_cmd->set_time(time);                        // 设定目标时间
new_cmd->set_position(position);                // 设定目标位置
new_cmd->set_velocity(velocity);                // 设定目标速度
new_cmd->set_acceleration(acceleration);        // 设定加速度
new_cmd->set_jerk(jerk);                        // 设定急动度
```

### 4.2 触发计算

~~~c++
Interpolation algorithm = ...;                  // 当前算法
algorithm.start(time_now,                       // 初始化，初始时间戳
                start_position,                 // 初始位置
                start_velocity);                // 初始速度

while (1) {
    algorithm.move(time_now);                       // 触发一次运算，提供当前时间戳

    position = algorithm.get_position();            // 返回计算位置
    velocity = algorithm.get_velocity();            // 返回计算速度
    acceleration = algorithm.get_acceleration();    // 返回计算加速度
    jerk = algorithm.get_jerk();                    // 返回计算急动度
}
~~~
